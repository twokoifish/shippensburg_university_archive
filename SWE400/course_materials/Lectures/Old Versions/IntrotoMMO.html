<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Intro to MMO</title></head><body><h1>Overall Architecture</h1><ul><li>Types of machines</li><ul><li>Client</li></ul><ul><li>One Server for each map</li></ul><ul><li>One Server for managing logins</li></ul><ul><li>Standalone app to assist with game management</li></ul><li>Within each, overall architecture is MVC</li><ul><li>Rich domain model</li><li>Command pattern for anyone to change the state of the machine</li><ul><li>possible GUI (on client and game manager)</li><li>messages coming in from other machines</li></ul><li>Data source&nbsp;</li><ul><li>RDS (amazon's relational db servers - mysql)</li><li>Mocked (for testing purposes)</li></ul></ul><li>Not really layered - more of a hexagonal architecture</li><ul><li>Domain in the middle</li><li>plugin-ins around the edge</li><ul><li>GUI</li><li>Datasource</li><li>Communication</li></ul></ul></ul><h1>Qualified Observable</h1><ul><li>Lots of things depend on seeing domain model state changes</li><li>Registering yourself as an observer requires knowing what to observe</li><ul><li>breaks our layering rules</li></ul><li>Added a "rim" around the domain to manage observers</li><ul><li>All status change points generate "reports" (implementing QualifiedObservableReport)</li><li>QualifiedObservableConnector&nbsp;</li><ul><li>is a singleton</li></ul><ul><li>allows QualifiedObservers to register/unregister as listeners for a given report type</li><ul><li>public void registerObserver(QualifiedObserver observer, Class&lt;? extends QualifiedObservableReport&gt; reportType)</li><li>public void unregisterObserver(QualifiedObserver observer, Class&lt;? extends QualifiedObservableReport&gt; reportType)</li></ul></ul><ul><li>manages HashMap mapping report types to obervers</li><li>When the model knows a piece of state has changed, it notifies the connector</li><ul><li>public void sendReport(QualifiedObservableReport report)<br></li></ul></ul></ul></ul><h1>Communication Protocol</h1><ul><li>"Messages" are information packets that are sent between machines</li><li>Every message type must implement Message</li><li>Every message type must have a packer that extends MessagePacker on the maching that is sending the message</li><ul><li>Must be in communication.packers package</li><li>Must report which types of Reports it reacts to</li><ul><li>public ArrayList&lt;Class&lt;? extends QualifiedObservableReport&gt;&gt; getReportTypesWePack();</li></ul><li>Must encode how the Report gets packaged into a Message</li><ul><li>public Message pack(QualifiedObservableReport object);</li></ul></ul><li>Every message type must have a handler that extends MessageHandler on the machine that is receiving the message</li><ul><li>Must be in communication.handler package</li><li>Must report which type of message it processes</li><ul><li>public Class&lt;?&gt; getMessageTypeWeHandle();</li></ul></ul><ul><li>Must encode what should happen when a message arrives</li><ul><li>public void process(Message msg);&nbsp;</li></ul></ul></ul></body></html>