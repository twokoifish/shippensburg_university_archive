<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Architectural Patterns</title></head><body><h1>Architectural Patterns</h1>The second narrative for <br>Mapping to Relational DBs<br><br>Want to separate SQL from the rest of the system<br><ul><li>Developers have trouble because they don&#8217;t understand it well, so specialists do most SQL coding</li><li>SQL embedded in other languages can be awkward</li><li>DBAs what to see the SQL to tune the DB</li></ul><br>So,
we need a Gateway (466) between us and the table.&nbsp; That Gateway
holds the SQL and the rest of the system is DBMS agnostic<br><br>Where are we?<br><img style="width: 585px; height: 435px;" alt="" src="ArchitecturalPatterns.jpg"><br><br><h2>&nbsp;Background Patterns</h2><ul><li>Gateway (466) - An object that encapsulates access to an external system or resource.</li><li>Transaction
Scripts (110) - Organizes business logic by procedures where each
procedure handles a single request from the presentation.</li><li>Domain Model (116) - An object model of the domain that incorporates both behavior and data.</li><li>Table Module (120) - A single instance that handles the business logic for all rows in a database table or view.</li><li>Data Transfer Object (401) - An object that carries data between processes in order to reduce the number of method calls.</li><li>Record Set (508) - An in-memory representation of tabular data</li><li>Lazy Load ( 200) - An object that doesn&#8217;t contain all of the data you need but knows how to get it</li><li>Identity
Map (195) - Ensures that each object gets loaded only once by keeping
every loaded object in a map.&nbsp; Looks up objects using the map when
referring to them</li><li>Unit of Work ( 184) - Maintains a list of
objects affected by a business transaction and coordinates the writing
out of changes and the resolution of concurrency problems.</li></ul><h2>Types of Gateways</h2><ul><li>Row Data Gateway (152) which has one object for each row that is returned from the DB</li><li>Table Data Gateway (144) which can return multiple rows in a Record Set (508) so there is one object per table.&nbsp;</li></ul><br><h2>Table Data Gateway (144)</h2>An object that acts as a Gateway (466) to a database table.&nbsp; One instance handles all of the rows within the table.<br><ul><li>Has methods for queries, updates, inserts, etc.</li><li>Each method specifies the individual affected by the call</li><li>Usually stateless (so methods can be static)</li><li>Basically encapsulates SQL actions</li></ul><h3>How do we return multiple items?</h3><ul><li>Data Transfer Object (401)</li><ul><li>Map of entries</li></ul><ul><ul><li>requires copying data out of the dataset</li></ul><ul><li>defeats compile time checking (especially without generics)</li></ul><ul><li>For Domain Model (116) return appropriate domain objects</li></ul><ul><li>bi-directional coupling which isn&#8217;t beautiful</li></ul></ul><li>Record Set (508)</li></ul><br><h3>When to use it</h3><ul><li>Simplest DB interface pattern as it maps to the DB easily</li><li>Can depend on the Domain Layer pattern</li><ul><li>Works well with Table Module (125)</li></ul><ul><li>Can be used with Transaction Scripts (110)</li></ul><li>Choice between this and Row Data Gateway (152) depends on whether operations depend on multiple rows in table</li><li>Sometimes make sense to make Data Mappers (165) use Table Data Gateway to access the DB</li><li>Stored DB procedures are often organized as Table Data Gateways</li></ul><h3>Interesting Quotes</h3>&#8220;Even a simple find-by-ID query will return multiple data items.&#8221;<br><br>&#8220;One
alternative is to return some simple data structure, such as a
map.&nbsp; A map works, but it forces data to be copied out of the
record set that comes from the database into the map.&nbsp; I think
that using maps to pass data around is bad form because it defeats
compile time checking and isn&#8217;t a very explicit interface leading to
bugs as people misspell what&#8217;s in the map.&nbsp; A better alternative
is to use a Data Transfer Object (401).&#8221;<br><h2>Row Data Gateway (152)</h2>An object that acts as a Gateway (466) to a single record in a data source. There is one instance per row.<br><ul><li>Responsible for type conversion between the stored and in memory representations</li><li>Where to place the method to find an object? (think about find vs. create)</li><ul><li>a constructor with the find information as parameters</li><li>a static method</li><li>a separate finder class that returns the retrieved objects</li></ul><li>How do we create new rows?</li><ul><li>a constructor with all of the necessary information</li><li>a static method</li></ul><li>Can be used with a view or a query as well as a table</li><li>if
two of these update the same row in the same table, we have to worry
about one overwriting the changes made by another.&nbsp; So we&#8217;d like
to have only one per row.&nbsp; (Identity Map (195) may be helpful to
prevent duplication)<br></li></ul><h3>Interesting Quotes</h3>&#8220;Also, if
you have two Row Data Gateway objects that operate on the same
underlying table, you may find that the second Row Data Gateway you
update undoes the changes on the first.&nbsp; There&#8217;s no general way to
prevent this; developers just have to be aware of how virtual Row Data
Gateways are formed.&#8221;<br><br>&#8220; I don&#8217;t use a Row Data Gateway when I&#8217;m
using a Domain model (116). If the mapping is simple, Active Record
(160) does the same job without an additional layer of code.&nbsp; If
the mapping is complex, Data Mapper (165) works better, as it&#8217;s better
at decoupling the data structure from the domain objects because the
domain objects don&#8217;t need to know the layout of the database.&#8221;<br><br>&#8220;I&#8217;ve
see Row Data Gateway used very nicely with Data Mapper (165). Although
this seems like extra work, it can be effective iff the Row Data
gateways are automatically generated from meta data while the Data
Mappers (165)&nbsp; are done by hand&#8221;<br><br><h2>Active Record (160)</h2>An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic to that data<br><br><ul><li>An
Active Record is used when the classes in a Domain Model (116) match
the underlying database&#8217;s structure.&nbsp; Each Active Record is
responsible for saving and loading from the DB and has domain logic for
operations in that data</li><li>fields should have 1-to-1 mapping to columns in the data </li><li>with no conversion except for foreign keys which may use Foreign Key Mapping (236)</li><li>if conversion is required by the rest of the system, put it in the getters and setters</li><li>make sure that appropriate conversion is always done</li><li>simplifies the persistence code</li><li>Typically has methods to</li><ul><li>construct a new instance for later insertion into the DB</li><li>static finder methods for common queries that return Active Record (160) objects</li><li>update the DB</li><li>get and set fields</li><li>some business logic<br></li></ul></ul><h3>When to use it</h3><ul><li>When domain logic isn&#8217;t too complex</li><li>When using Domain Model (116) have to choose between Active Record (160) and Data Mapper (166)</li><li>Active Record (160) is easy to build and understand if objects are isomorphic to underlying DB schema</li><li>If business logic is complex, it won&#8217;t map easily, so use Data Mapper (166)</li><li>If
Transcription Scripts (110) are getting duplication of code or
complexity when updating the DB, then wrap tables in a Gateway (466)
and start moving behavior so tables evolve into Active Records.</li></ul><br>Difference between Row Data Gateway (152) and Active Record (160):<br>if it contains business logic, it is an Active Record.<br><h3>Interesting quotes</h3>&#8220;The one-to-one match of domain classes to tables starts to fail as you factor domain logic into smaller classes&#8221;<br><br>&#8220;Another
argument against Active Record is the fact that is couples the object
design to the database design. This makes it more difficult to refactor
either design as the project moves forward.&#8221;<br><br>&#8220;Active Record is a
good pattern to consider if you&#8217;re using Transaction Scripts (110) and
are beginning to feel the pain of code duplication and the difficulty
in updating scripts and tables. . .<br><h2>Data Mapper (165)</h2>A
layer of Mappers (473) that moves data between objects and a database
while keeping them independent of each other and the mapper itself.<br><br><ul><li>DBs don&#8217;t deal with inheritance and contained collections easily, but those are good techniques in a Domain Model (116). &nbsp;</li><li>This makes the objects in the Domain Model (116) not map easily to rows in the DB.&nbsp; (paradigm chasm) &nbsp;</li><li>Data Mapper (165) must span that chasm</li></ul><h3>When to use it:</h3><ul><li>Easiest case: object is stored as a row in a table.</li><ul><li>uses an Identity Map (195) to find/load the object.</li></ul><ul><li>Can write the object with simple SQL</li></ul><ul><li>Including the Data Mapper (165) allows the entire layer to be substituted to work in different DBs or for testing purposes</li></ul><li>Use when the data model includes</li><ul><li>inheritance</li></ul><ul><li>collections</li></ul><ul><li>translations</li></ul><ul><li>multiple tables</li></ul><ul><li>Data Mapper (165) hides all of that complexity from the rest of the system</li></ul><li>When dealing with updates and inserts, must know what has changed, been created or destroyed. &nbsp;</li><ul><li>Unit of Work (184) can encapsulate that information&nbsp;</li></ul><li>A single request can result in a large number of related objects to be retrieved from multiple tables</li><ul><li>Lazy Load (200) can defer things we don&#8217;t need</li><li>Otherwise, a join of multiple queries can be more efficient than individual queries<br></li></ul><li>Hand built mappers usually have one per domain class or one at the root of an inheritance hierarchy</li><li>Using Meta Mapping (306) can allow us to have only one mapping class</li><ul><li>requires external specifications of the mappings</li></ul><ul><li>may end up with so many finder methods that you what to separate them by domain class/hierarchy</li></ul><li>The Mappers are going to require Identity Maps (195) to maintain the identity of the objects it reads.</li><ul><li>have a Registry (480) of Identity Maps (195) or</li><li>each finder holds its own Identity Map (195)<span style="font-weight: bold;"></span></li></ul><li><span style="font-weight: bold;"></span>Since the Data Mapper (165) has to be able to fill in the fields, you must have public methods to do that.<br></li><ul><li>If
you are worried about people using them indiscriminately, use a status
field to say that it is loading and only let them be changed if the
status is true.</li></ul><ul><li>throw exception if accessed at wrong time</li></ul><ul><li>name the method to warn people this will happen</li></ul><li>To create object either</li><ul><li>use a rich constructor that fills in the minimum required fields</li></ul><ul><ul><li>allows no setters for immutable fields</li></ul></ul><ul><ul><li>will never have partial objects</li></ul></ul><ul><ul><li>circular references can be tricky</li></ul></ul><ul><li>create empty object and fill in required fields separately</li></ul><li>When you want relational schema and object model to evolve independently</li><li>Most common with Domain Model (116) allowing the model objects to ignore DB in design and test</li><li>But</li><ul><li>adds a layer that Active Record (160) doesn&#8217;t require</li><li>simple domain logic probably doesn&#8217;t require it</li><li>Wouldn&#8217;t use it without Domain Model (116), but can use Domain Model (116) without Data Mapper (165) <br></li></ul></ul><h1>Relationship to Domain Logic</h1><ul><li>Table Module (125) makes it logical to use a Table Data Gateway (144) </li><ul><li>may be implemented as stored DB procedures</li></ul><li>Domain Model (116) has some choices:</li><ul><li>can use Row Data Gateway (152)</li></ul><ul><li>can use Table Data Gateway (144)</li></ul><ul><li>can make our Domain Model objects responsible for DB interactions</li></ul><ul><ul><li>is Active Record (160)</li></ul></ul><ul><ul><li>can think of that as combining a Row Data Gateway (152) with domain logic</li></ul></ul><li>Transaction Scripts (110)<br></li></ul><ul style="margin-left: 40px;"><li>Extra indirection of Gateway (466) may not be necessary</li><li>As domain logic gets more complex, Active Record (160) will start to break down.</li><li>As
we refactor the Active Records into separate classes, the one-to-one
mapping of class to DB table breaks (especially if we need inheritance)
</li></ul><ul><li>We would also like to be able to test complex domain logic w/o reading the DB</li><ul><li>A Gateway (466) can allow us to substitute alternative functionality for testing (mocking the DB interactions the tests require)</li></ul><ul><li>A better route might be to use a Data Mapper (165) to make the mapping from domain objects to tables.</li></ul></ul></body></html>