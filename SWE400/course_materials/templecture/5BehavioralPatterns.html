<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>5BehavioralPatterns</title></head><body><h1>Behavioral Patterns</h1><h2>Lazy Load, Unit of Work and Identity Map</h2><br>Where Are We?<br><img style="width: 417px; height: 393px;" alt="" src="BehavioralPatterns.jpg"><br><h2>Lazy Load&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</h2>Read the book together!<br><br><h2>Concurrency Issues</h2><ul><li>When we read data, hold it in memory, and modify it, we have to worry about how to write it back</li><li>We may have only modified a little bit and not want to write the whole thing back out</li><li>We have to worry about what happens if someone else (another object, another thread, another system) is doing the same thing</li><li>We may want to ensure that only one such object exists at any point in time</li></ul><br><h2>Unit Of Work</h2>&#8220;Maintains
a list of object affected by a business transaction and coordinates the
writing out of changes and the resolution of concurrency patterns&#8221;<br><br>Object with these kinds of operations:<br><ul><li>registerNew(object)</li><li>registerDirty(object)</li><li>registerClean(object)</li><li>registerDeleted(object)</li><li>commit()</li></ul><h3>Big Picture</h3><ul><li>As soon as you start doing something to an object that will eventually get persisted, register it with the unit of work. </li><li>Every time you change it, tell the unit of work</li><li>When you are done, tell the unit of work to commit the changes</li></ul><ul><li>If you are worried that other people are changing an object you are using, register that object, too.</li><li>Can
also help with ensuring referential integrity by persisting fields in
the necessary order (if the DB checks referential integrity before the
commit of a transaction)</li></ul><h3>What Does UofW Do on Commit?</h3><ul><li>Opens a transaction</li><li>Does concurrency checking (more on that later)</li><li>Writes the changes to the DB</li><li>Commits the change</li></ul>The challenge is figuring out how the UofW knows what has changed . . .<br><br><h3>What Objects to track?</h3><ul><li>Caller Registration </li><ul><li>User of an object registers it with the unit of work</li></ul><li>Object Registration</li><ul><li>The object itself knows to register itself&nbsp; by calling registerClean(object) at creation<br></li></ul></ul><h3>Caller Registration</h3><ul><li>User of the object registers the object with the UofW when it changes something</li><li>User of the object persists<h3><img style="width: 509px; height: 470px;" alt="" src="CallerRegistration.png"></h3></li></ul><ul><li>Allows people to have objects that change without persisting.&nbsp; (is that a good idea?)</li><li>What happens if the user forgets to register dirty?</li></ul><h3>Object Registration</h3><ul><li>Object communicates with UofW as appropriate</li><li>Client still calls commit (really?)(How does he find the UofW object?)</li></ul><img src="https://lh4.googleusercontent.com/NUAN1BgWtWiWooUnxTsTc1Rd-shQXpsWyyqtoxAylZvHfQ9GfCsmb9QRAdtXoB_VPsfYGFWYgR7pfIVILCbdC4LIXjJIMaKKnb2qxLxbsmF2twIRBc4ZjWx-4L4WozOc3DcPUhgtOEI"><br><ul><li>Developer of object could still forget to include registerDirty</li><li>Could we automatically generate that?</li><li>Aspect Oriented programming!</li></ul><h3>Unit Of Work Controller</h3><ul><li>UofW is responsible for everything</li><li>UofW reads the object and holds a copy of the clean version</li><li>When asked to commit, UofW compares dirty to clean to infer what needs to be persisted</li></ul>&#8220;A
hybrid approach is to take copies only of changed objects.&nbsp; This
requires registration, but it supports selective update and greatly
reduces the overhead of the copy of there are many more reads than
updates.&#8221;<br><h3>Object Creation</h3>What if we want to create an object that won&#8217;t be persisted (transient objects)<br><ul><li>Caller registration makes this easy</li><li>Object registration - transient constructor that doesn&#8217;t register the unit of work</li><li>Special Case of UofW that does nothing with a commit</li><li>This gets to an important point - how are the objects finding their UofW? (next slide)</li></ul><br><h3>How Do We Find the Right UofW object?</h3><ul><li>A thread-scoped Registry (480)</li><ul><li>What the . . . is that?</li></ul><li>Pass the UofW to the object that needs it (Strategy Pattern)</li><ul><li>Allows different behavior in different situations (ex. test vs. production)</li></ul></ul>&#8220;In either case make sure that more than one thread can&#8217;t get access to a Unit of Work - there lies the way to madness&#8221;<br><ul><li>Why?</li><li>Does that limit how we can spread functionality across threads?</li></ul><h3>Batch Updates&nbsp;&nbsp; &nbsp;</h3>If your DB is remote, batch update lets you send a sequence of sql statements in one unit. &nbsp;<br>UofW is the obvious place to build them and to deal with any possible failures<br><br><h3>UofW Isn&#8217;t Just for Databases</h3>We can use UofW for any transactional resource<br><ul><li>Message queues</li><li>Transaction monitors - did you google that?</li><li>Disconnected data sources</li></ul><h2>Identity Map</h2>&#8220;Ensures
that each object gets loaded only once by keeping every loaded object
in a map.&nbsp; Looks up objects using the map when referring to them.&#8221;<br><br>Is this the way you would build it:<br><br>&#8220;When
you load an object from the from the database, you first check the
map.&nbsp; If there&#8217;s an object in it that corresponds to the one
you&#8217;re loading, you return it.&nbsp; If not, you go to the database,
putting the objects into the map for future reference as you load them.&#8221;<br><br>Who is &#8220;you&#8221; in that description?<br><h3>Choice of Keys</h3><ul><li>Primary Key</li><ul><li>Good if it is a single column and immutable</li></ul><li>What if the object spans tables?</li><li>Surrogate vs natural keys?</li><li>What do we do if the key spans columns?</li><ul><li>When would that happen?</li></ul></ul><h3>Explicit vs. Generic Identity Map</h3><ul><li>Explicit</li><ul><li>Finders for each object type directly interface with the Identity Map</li></ul><ul><li>Requires new finder for each type of object being tracked</li></ul><ul><li>Compile time checking for object types</li></ul><ul><li>Would you really have one big identity map class or one for each type?</li></ul><ul><ul><li>How many identity map objects are there?</li></ul></ul><ul><ul><li>If we have one for each type, what would you want to inherit from a superclass?</li></ul></ul><li>Generic</li><ul><li>One finder method for every kind of object (params are type and key)</li></ul><ul><li>He claims this is infinitely reusable (do you believe him?) </li></ul><ul><li>Requires all types to have the same key type</li></ul><ul><li>Motivates Identity Field pattern for keys (All keys are members of the same class)</li></ul></ul><h3>How Many Identity Maps Should There Be?</h3>One Per Class or Per Table (which obeys our layer architecture?)<br><ul><li>What if there is inheritance?</li><ul><li>Single map per inheritance tree</li></ul><ul><ul><li>Makes polymorphism work more smoothly</li></ul></ul><ul><li>Depends on which pattern you used to map objects to the db</li></ul></ul>One Per Session<br><ul><li>Requires db unique keys</li></ul><h3>Where To Put Them</h3><ul><li>Each session needs its own Identity Map</li><ul><li>If you have a UofW, that is the obvious place to put it</li></ul><ul><li>If not, a Registry tied to the session can work</li></ul><li>Why one per session?</li><ul><li>We would need &#8220;transactional protection&#8221; otherwise (what the . . .?)</li></ul><ul><li>Exceptions</li></ul><ul><ul><li>Use the object DB as a transactional cache</li></ul></ul><ul><ul><ul><li>Might give a performance benefit</li></ul></ul></ul><ul><ul><li>Read only objects</li></ul></ul><ul><ul><ul><li>Why would we even identity map them?</li></ul></ul></ul></ul>&#8220;Even
if you&#8217;re inclined to have only one Identity Map you can split it into
two along read-only and updatable lines. You can avoid clients having
to know which is which by providing an interface that checks both maps.&#8221;<br></body></html>